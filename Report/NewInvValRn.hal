external function Boolean IsEnterprise();external function Boolean HasItemGroups();external function Boolean HasContactClassification();external function Boolean HasItemClassification();external procedure InvListVarieties(record RcVc,record INVc,string,string,string,string,record CostAccBlock,Boolean,var Boolean,                                    var Boolean,var string,var val,var val,var val,var val,roundmode,var val,string,vector val);external procedure HTConsigment(Integer, var string);external procedure FindStockValueAtPosition(string,string,string,var record PISVc);external procedure AddSupersessionsInvList(record RcVc,record INVc,string,record CostAccBlock,roundmode,string,var val,var val,var val);external function roundmode GetCostRoundMode(record RoundBlock);external function roundmode DefaultRoundMode();external procedure GetItemCostPrc(record INVc,record CostAccBlock,record ITVc,Integer,var val);external procedure PrintSerialNumbers_InvVal(record INVc,string,Integer,val,Date,string,Integer); external function val ConsigmentStockQty(string,string,Date);external function val FindCPPriceBackdated(Integer,record INVc,string,val,Date,Boolean);external function Integer ArtCodeCostPricePerLocation(string);external function val FindCostPriceSerialNumberBackDated(Integer,record INVc,string,string,val,val,Date,Boolean,Integer,Boolean,Integer,Integer);external function val GetStockQty(string,string,Date,Boolean);external procedure GetCostModel(record INVc,record CostAccBlock,var record ITVc,var Integer,var Integer,Boolean);external function Integer WAPerLocation(record INVc,record ITVc,record CostAccBlock);external function Integer ItemCostPerLocation(record INVc);external function val FindCostPriceLIFOBackDated(Integer,record INVc,string,string,val,val,Date,Boolean,Integer,Boolean,Integer,Integer,Integer);external function val FindCostPriceFIFOBackDated(Integer,record INVc,string,string,val,val,Date,Boolean,Integer,Boolean,Integer,Integer,Integer);external function val FindWAPriceBackdated(Integer,record INVc,string,val,Date,Boolean,Integer);external function Boolean ReadFirstItemInclClosed(string,var record INVc,Boolean,Boolean);external function Boolean ReadFirstItem(string,var record INVc,Boolean,Boolean);external function Boolean FindItemVAR(string,var string,var string,var string,var string);external function val GetStockQty2(string,string,Date,Boolean,Integer);external procedure HTArts(string, string, var string);external procedure HTDepartment(string,var string);external procedure HTArtGroup(string, var string);external procedure HTSupplier(string, var string);external procedure GetItemGroupDescription(string,var string);external procedure CalcSum(val,val,val,val,var val,Integer);external procedure FindStockValue2(record INVc,string,string,Integer,Date,Integer,Boolean,var val,var val,var val,Integer,Integer,Integer,Integer,Boolean,vector val);external procedure HTItemClass(string,var string);external procedure HTCustClassType(string,var string);external function Boolean SetInSet2(string,string);external procedure ItemClassTypef(string,string,var Boolean);external function Boolean FillItemVarArray(string,string,date,var array string,var array val,var Integer,var string,var string,var string,var string);//Edit***************************Sasha2,10:48 09.09.2014 {procedure LoopNewInvVal(record RcVc RepSpec)begin  record INVc INr;  record ItemStatusVc ISr;  boolean TrHs,testf;  integer i,pos;  	TrHs = true;  	INr.Code = "";  	while (LoopMain(INr,1,TrHs)) begin  		testf = true;  		if (NonBlank(RepSpec.f1) and !SetInSet(INr.Code,RepSpec.f1)) then begin testf = false; end;  		if (RepSpec.flags[18]==0 and INr.Terminated<>0) then begin testf = false; end;  		if (INr.ItemType!=kItemTypeStocked) then begin testf = false; end;  		if (testf) then begin				pos = 0; 				StartFormat(15);				OutString(pos,0,INr.Code,false);  			OutString(pos+=30,0,INr.Name,false);  			OutString(pos+=60,0,INr.BarCode,false);  			OutString(pos+=40,0,INr.AlternativeCode,false);  			ISr.Code = INr.Code;  			if (NonBlank(RepSpec.f2)) then begin  				ISr.Location = RepSpec.f2;  			end else begin  				ISr.Location = ";;;";  			end;  			ReadFirstMain(ISr,2,true);  			OutVal(pos+=40,0,ISr.Instock,M45Val,false);  			OutVal(pos+=30,0,INr.Weight,M45Val,false);  			OutVal(pos+=30,0,INr.Weight*ISr.Instock,M45Val,false);  			OutVal(pos+=30,0,INr.Volume,M45Val,false);  			OutVal(pos+=30,0,INr.Volume*ISr.Instock,M45Val,false);  			OutVal(pos+=30,0,ISr.RsrvQty,M45Val,false);  			OutVal(pos+=30,0,ISr.OrddOut,M45Val,false);  			OutVal(pos+=30,0,ISr.Instock-ISr.RsrvQty,M45Val,false);  			OutVal(pos+=40,0,ISr.Instock-ISr.OrddOut,M45Val,false);  			EndFormat;		  	Gray_Divider(0,1);	  		end;	  	end;  	Black_Divider(2,1); 	  return;end; //Edit***************************Sasha2,10:48 09.09.2014 }global  //Edit***************************Sasha2,11:43 02.09.2014 {procedure NewInvValRn(record RcVc RepSpec)begin  record CostAccBlock CAb;  string 255 tstr;  Integer rw;  integer pos;  integer i; //Edit***************************Sasha2,13:03 03.09.2014    BlockLoad(CAb);  StartReportJob(USetStr(2322) & " (modified)");  if (RepSpec.PocketPC == 0) then begin    rw = 1;    if ((nonblank(RepSpec.f1)) or (blank(RepSpec.AccStr))) then begin      HTArts(RepSpec.f1,RepSpec.f1,tstr);      Header(rw,tstr,1);      rw = rw + 1;    end;    if (nonblank(RepSpec.f2)) then begin      tstr = USetStr(2768) & RepSpec.f2;    end else begin      tstr = USetStr(8961);    end;    Header(rw,tstr,1);    rw = rw + 1;    /*if (HasItemGroups) then begin      HTArtGroup(RepSpec.f3,tstr);      if (nonblank(tstr)) then begin        Header(rw,tstr,1);        rw = rw + 1;      end;    end;    if (nonblank(RepSpec.FirstAcc)) then begin      tstr = USetStr(2779) & " " & RepSpec.FirstAcc;      Header(rw,tstr,0);    end;    if (HasItemClassification) then begin      HTItemClass(RepSpec.f4,tstr);      if (nonblank(tstr)) then begin        Header(rw,tstr,1);        rw = rw + 1;      end;     end;    if (HasContactClassification) then begin      HTCustClassType(RepSpec.f5,tstr);      if (nonblank(tstr)) then begin        Header(rw,tstr,1);        rw = rw + 1;      end;     end;    if (nonblank(RepSpec.LastAcc)) then begin      HTSupplier(RepSpec.LastAcc,tstr);      Header(rw,tstr,1);      rw = rw + 1;    end;    if ((ProgramType!=typFirstOffice) and IsBooks==false) then begin      if (RepSpec.flags[1]==0) then begin        tstr = USetStr(2345);       end;        if (RepSpec.flags[1]==1) then begin        tstr = USetStr(2346);            end;        Header(rw,tstr,1);      rw = rw + 1;    end;    if (IsEnterprise) then begin      HTConsigment(RepSpec.flags[12],tstr);      Header(rw,tstr,0);    end;    switch (RepSpec.flags[11]) begin      case 0:         switch (CAb.PrimaryCostModel) begin          case 4:            tstr = USetStr(10554 + CAb.QueuedCostModel);          otherwise            tstr = USetStr(10550 + CAb.PrimaryCostModel);        end;            case 1: tstr = USetStr(10550+RepSpec.flags[11]);      case 2: tstr = USetStr(10550+RepSpec.flags[11]);      case 3: tstr = USetStr(10550+RepSpec.flags[11]);      otherwise            tstr = USetStr(10554 + CAb.QueuedCostModel);    end;    Header(rw,USetStr(10549) & ": " & tstr,1);    rw = rw + 1;*/  end else begin  end;  EndHeader;  if (blank(RepSpec.f5) and (RepSpec.flags[2]==4)) then begin    StartFormat(15);    OutString(140,0,USetStr(20098),false);    EndFormat;      goto LInvValRn;  end;  	pos = 0;	StartFormat(15);  OutString(pos,0,USetStr(2302),false); //код  OutString(pos+=30,0,USetStr(2303),false); //найм.  OutString(pos+=60,0,USetStr(31016),false);//штрихкод  OutString(pos+=40,0,USetStr(31017),false);//код пост.  OutString(pos+=40,0,USetStr(2330),false);//остаток  OutString(pos+=30,0,USetStr(14533) & "," & USetStr(31018),false);//вес за ед.  OutString(pos+=30,0,USetStr(14533) & "," & USetStr(31019),false);//вес общ.  OutString(pos+=30,0,USetStr(5506) & "," & USetStr(31018),false);//объем за ед.  OutString(pos+=30,0,USetStr(5506) & "," & USetStr(31019),false);//объем общ.  OutString(pos+=30,0,USetStr(11540),false); //резерв  OutString(pos+=30,0,USetStr(31020),false); //в счетах  OutString(pos+=30,0,USetStr(31021),false); //Дост.с учет.рез-ва  OutString(pos+=40,0,USetStr(31022),false); //ДДост.с учет.счетов  EndFormat;  Gray_Divider(0,1);   LoopNewInvVal(RepSpec);  LInvValRn:;   EndJob;  return;end;  